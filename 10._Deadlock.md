## Deadlock(교착상태)

**교착상태 필요조건**

1. Mutual exclusion(상호배타)
2. Hold and wait(보유 및 대기)
3. No Preemption(비선점, 강제로 뺏을 수 없음)
4. Circular wait(환형대기)

**-> 이 조건이 만족되면 교착상태가 일어날 수도 있다.(자주 일어나는 것은 아님)**

### 자원

- deadlock이 발생하는 것은 결국 자원때문이다.

1. 동일자원

- 동일 형식(type) 자원이 여러 개 있을 수 있다.(**instance**)
- 예 : 동일 CPU 2개, 동일 프린터 3개 등

2. 자원의 사용

- 요청(request) -> 사용(use) -> 반납(release)

3. 자원 할당도(Resource Allocation Graph)

- 어떤 자원이 어떤 프로세스에게 할당되었는가?
- 어떤 프로세스가 어떤 자원을 할당 받으려고 기다리고 있는가?
- **자원** : 사각형, **프로세스** : 원, **할당** : 화살표  
  ex. 자원 : 젓가락, 프로세스 : 철학자

- 식사하는 철학자 문제에서 원이 만들어지지 않게 하려면?
  -> 짝수 철학자는 오른쪽 젓가락을 먼저 들고 홀수 철학자는 왼쪽 젓가락을 먼저 들게 하면 된다. -> 환형대기가 깨짐.

### 교착상태 처리

1. 교착상태 방지 (Deadlock Prevention)

- 교착상태 4가지 필요조건 중 한가지 이상 불만족

  - 상호배타  
    -> 자원을 공유하게 만들면 된다. 하지만 선천적으로 불가능한 조건(CPU나 메모리 공유...불가능)

  - 보유 및 대기  
    -> 자원을 가지고 있으면서 다른 자원을 기다리지 않게 하기, 자원을 한꺼번에 잡거나 하나만 있고 다른 자원이 없을 시 둘 다 놓아버리기  
    -> 프로세스가 진행하지 못할 확률이 높고 자원의 활용률이 떨어짐.

  - 비선점  
    -> 강제로 가져오기  
    -> 일반적으로 불가능

  - 환형대기  
    -> 자원에 번호부여, 번호의 오름차순으로 자원 요청하기 -> 자원의 활용률이 떨어짐

2. 교착상태 회피 (Deadlock Avoidance)

- 자원요청에 대한 잘못된 승인으로 인해 process를 돌릴 수 없는 상태
  -> 불안전 할당 -> 교착상태 -> 안전한 할당을 해야한다.
- 이런 문제 해결(안전 할당)을 **Banker's Algorithm**이라고 한다.

-> 1번과 2번은 Deadlock이 일어나지 않도록 하는 방법

3. 교착상태 검출 및 복구 (Deadlock Detection & Recovery)

- Deadlock이 일어나는 것을 허용
- Deadlock 발생 시 복구
- Process가 원하는대로 자원을 나누어주고 Deadlock이 일어나는지 주기적으로 검사한다.
- **검출** : 검사에 따른 추가 부담이 된다.
- **복구** : 주기적으로 상태를 기억해야 한다(메모리 소비), 그 전의 상태로 돌릴 수 없을 때 process의 일부를 강제종료해야한다.

4. 교착상태 무시 (Don't care)

- 교착상태 발생 시 재시동(pc는 가능하다.)
