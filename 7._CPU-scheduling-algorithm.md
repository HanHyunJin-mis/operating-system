### CPU 스케쥴링

- CPU를 어떻게 효과적으로 나눠줄까?

### 1. Preemptive(선점) vs Non-Preemptive(비선점)

- scheduling criteria
  - CPU Utilization(CPU 이용률, %) : CPU가 얼마나 이용되고 있는가?(많이 활용되는 것이 좋음)
  - Throughtput(처리율, jobs/sec) : 단위시간당 몇개의 작업을 처리하는가? (작업 방식에 따른 처리율)
  - Turnaround(반환시간) : 프로세스가 들어갔다가 작업을 끝내고 나오기까지 걸린 시간 (짧을수록 좋다.)
  - Waiting time(대기시간, sec) : CPU 서비스를 받기 위해 ready queue에서 얼마나 기다렸는가
  - Response time(응답시간) : interactive system에서 중요하다.

### 2. CPU scheduling algorithm

1. First-Come, First-Served(FCFS)

- Non-preemptive scheduling
- 꼭 좋은 성능을 나타내는 것은 아니다.
- Convoy Effect(호위효과) : FCFS의 단점, 첫번째 프로세스가 오래 걸리면 뒤의 프로세스들이 오랫동안 기다려야 하는 상황(호위하는 것과 같다고 해서 붙여짐)  
  </br>

2. Shortest-Job-First(SJF)

- Preemptive or Non-preemptive scheduling
- 시간이 적게 걸리는 일부터 먼저 처리하는 것
- 대기시간을 줄인다는 측면에서는 가장 좋다.
- 단점 : 비현실적 -> 실제로 프로세스가 cpu 시간을 얼마나 사용할지를 모름

- Preemptive : 남아있는 시간이 얼마나 되는지 보고 가장 짧은 것부터 실행 -> shortest-remaining-time-first(최소잔여시간 우선)  
  </br>

3. Priority(우선순위)

- Preemptive or Non-preemptive scheduling
- 일반적으로 정수 값을 나타낸다.
- 숫자가 작은 것이 우선순위가 높다. (무조건 우선순위가 높은 것 우선)
- **starvation(기아)** : 프로세스가 레디 큐에 들어가 우선순위가 너무 낮아서 실행되지 못하는 상태
- **aging** : starvation의 솔루션, OS가 ready queue를 주기적으로 검사해서 점진적으로 우선순위를 높여주는 작업

</br>

4. Round-Robin(RR)

- Preemptive : 일정한 time quantum이 흐르면 다음 프로세스로 넘아가기 때문에
- 빙글빙글 돌면서 scheduling 하는 것
- Time-sharing system(시분할/시공유 시스템)
- Time quantum이 되면 Round-Robbin은 FCFS와 같다.
- 반대로 Time quantum이 0이 되면 switching이 빈번하게 되어 여러개의 프로그램이 동시에 돌아가는 것처럼 보인다. -> context switching overhead 발생
- 결국 좋은 time quantum을 잡는 것이 중요하다.
  </br>

5. Multilevel Queue

</br>

6. Multilevel Feedback Queue
